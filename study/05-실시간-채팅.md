# 💬 실시간 채팅 구현 이해하기

## 📌 WebSocket이란?

**WebSocket**은 실시간 양방향 통신을 위한 프로토콜입니다.
- HTTP와 달리 **연결을 유지**하며 통신
- 전화 통화처럼 **실시간 대화** 가능
- 채팅, 게임, 실시간 알림에 사용

### HTTP vs WebSocket
```
[HTTP - 편지]
클라이언트: "데이터 주세요" →
                            ← 서버: "여기 있습니다"
(연결 종료)

[WebSocket - 전화]
클라이언트 ←→ 서버
(연결 유지, 실시간 대화)
```

## 🔌 WebSocket 연결 과정

```
1. 핸드셰이크 (악수)
   클라이언트 → 서버: "WebSocket으로 연결하고 싶어요"
   
2. 업그레이드
   서버 → 클라이언트: "좋아요, WebSocket으로 전환할게요"
   
3. 연결 유지
   양방향 실시간 통신 시작
   
4. 연결 종료
   어느 한쪽이 연결을 끊을 때까지 유지
```

## 🖥️ 백엔드 구현 (Django Channels)

### 1. Django Channels 설정
```python
# settings.py
INSTALLED_APPS = [
    'daphne',  # ASGI 서버
    'channels',  # WebSocket 지원
    # ...
]

# ASGI 설정
ASGI_APPLICATION = 'chat_project.asgi.application'

# 채널 레이어 설정 (메시지 브로커)
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('127.0.0.1', 6379)],
        },
    },
}
```

### 2. ASGI 설정
```python
# asgi.py
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
import chat.routing

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 
                     'chat_project.settings')

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(
            chat.routing.websocket_urlpatterns
        )
    ),
})
```

### 3. WebSocket 라우팅
```python
# chat/routing.py
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(
        r'ws/chat/(?P<session_id>\w+)/$', 
        consumers.ChatConsumer.as_asgi()
    ),
]
```

### 4. Consumer (WebSocket 핸들러)
```python
# chat/consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from .models import ChatSession, Message
from llm.llm_service import LLMService

class ChatConsumer(AsyncWebsocketConsumer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.llm_service = LLMService()
    
    async def connect(self):
        """WebSocket 연결 시작"""
        self.session_id = self.scope['url_route']['kwargs']['session_id']
        self.room_group_name = f'chat_{self.session_id}'
        
        # 룸 그룹에 참가
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # 환영 메시지
        await self.send(text_data=json.dumps({
            'type': 'connection',
            'message': '채팅에 연결되었습니다.'
        }))
    
    async def disconnect(self, close_code):
        """WebSocket 연결 종료"""
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        """메시지 수신 및 처리"""
        data = json.loads(text_data)
        message = data['message']
        
        # 사용자 메시지 저장
        await self.save_message(message, is_user=True)
        
        # 사용자 메시지 브로드캐스트
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message,
                'is_user': True
            }
        )
        
        # AI 응답 생성 (스트리밍)
        ai_response = ""
        async for chunk in self.llm_service.generate_stream(message):
            ai_response += chunk
            
            # 각 청크를 실시간으로 전송
            await self.send(text_data=json.dumps({
                'type': 'ai_chunk',
                'chunk': chunk
            }))
        
        # 완성된 AI 응답 저장
        await self.save_message(ai_response, is_user=False)
        
        # AI 응답 완료 신호
        await self.send(text_data=json.dumps({
            'type': 'ai_complete',
            'message': ai_response
        }))
    
    async def chat_message(self, event):
        """그룹 메시지 전달"""
        await self.send(text_data=json.dumps({
            'type': 'message',
            'message': event['message'],
            'is_user': event['is_user']
        }))
    
    @database_sync_to_async
    def save_message(self, content, is_user):
        """메시지 데이터베이스 저장"""
        session = ChatSession.objects.get(id=self.session_id)
        Message.objects.create(
            session=session,
            content=content,
            is_user=is_user
        )
```

## 💻 프론트엔드 구현

### 1. WebSocket 서비스
```typescript
// services/websocket.ts
export class WebSocketService {
  private socket: WebSocket | null = null;
  private messageHandlers: ((data: any) => void)[] = [];
  
  connect(sessionId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.socket = new WebSocket(
        `ws://localhost:8000/ws/chat/${sessionId}/`
      );
      
      this.socket.onopen = () => {
        console.log('WebSocket 연결 성공');
        resolve();
      };
      
      this.socket.onerror = (error) => {
        console.error('WebSocket 에러:', error);
        reject(error);
      };
      
      this.socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      };
      
      this.socket.onclose = () => {
        console.log('WebSocket 연결 종료');
        this.reconnect(sessionId);
      };
    });
  }
  
  private handleMessage(data: any) {
    // 메시지 타입별 처리
    switch(data.type) {
      case 'connection':
        console.log('연결됨:', data.message);
        break;
        
      case 'ai_chunk':
        // AI 응답 스트리밍
        this.messageHandlers.forEach(handler => 
          handler({
            type: 'chunk',
            content: data.chunk
          })
        );
        break;
        
      case 'ai_complete':
        // AI 응답 완료
        this.messageHandlers.forEach(handler => 
          handler({
            type: 'complete',
            content: data.message
          })
        );
        break;
        
      case 'message':
        // 일반 메시지
        this.messageHandlers.forEach(handler => 
          handler({
            type: 'message',
            content: data.message,
            isUser: data.is_user
          })
        );
        break;
    }
  }
  
  sendMessage(message: string) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({ 
        message 
      }));
    }
  }
  
  onMessage(handler: (data: any) => void) {
    this.messageHandlers.push(handler);
  }
  
  private reconnect(sessionId: string) {
    console.log('재연결 시도...');
    setTimeout(() => {
      this.connect(sessionId);
    }, 3000);
  }
  
  disconnect() {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
  }
}
```

### 2. React 컴포넌트에서 사용
```typescript
// components/ChatInterface.tsx
import React, { useState, useEffect, useRef } from 'react';
import { WebSocketService } from '../services/websocket';

const ChatInterface: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [currentAIMessage, setCurrentAIMessage] = useState('');
  const [isConnected, setIsConnected] = useState(false);
  const wsService = useRef(new WebSocketService());
  
  useEffect(() => {
    // WebSocket 연결
    const connectWebSocket = async () => {
      try {
        await wsService.current.connect(sessionId);
        setIsConnected(true);
        
        // 메시지 핸들러 등록
        wsService.current.onMessage((data) => {
          if (data.type === 'chunk') {
            // AI 응답 스트리밍 업데이트
            setCurrentAIMessage(prev => prev + data.content);
          } else if (data.type === 'complete') {
            // AI 응답 완료
            setMessages(prev => [...prev, {
              content: data.content,
              isUser: false,
              timestamp: new Date()
            }]);
            setCurrentAIMessage('');
          } else if (data.type === 'message') {
            // 일반 메시지
            setMessages(prev => [...prev, {
              content: data.content,
              isUser: data.isUser,
              timestamp: new Date()
            }]);
          }
        });
      } catch (error) {
        console.error('연결 실패:', error);
        setIsConnected(false);
      }
    };
    
    connectWebSocket();
    
    // 컴포넌트 언마운트 시 연결 종료
    return () => {
      wsService.current.disconnect();
    };
  }, [sessionId]);
  
  const sendMessage = () => {
    if (!input.trim() || !isConnected) return;
    
    // 사용자 메시지 추가
    setMessages(prev => [...prev, {
      content: input,
      isUser: true,
      timestamp: new Date()
    }]);
    
    // WebSocket으로 전송
    wsService.current.sendMessage(input);
    
    // 입력창 초기화
    setInput('');
  };
  
  return (
    <div className="chat-container">
      <div className="connection-status">
        {isConnected ? '🟢 연결됨' : '🔴 연결 안됨'}
      </div>
      
      <div className="messages">
        {messages.map((msg, idx) => (
          <div 
            key={idx} 
            className={`message ${msg.isUser ? 'user' : 'ai'}`}
          >
            <div className="avatar">
              {msg.isUser ? '👤' : '🤖'}
            </div>
            <div className="content">
              {msg.content}
            </div>
          </div>
        ))}
        
        {/* AI 응답 스트리밍 표시 */}
        {currentAIMessage && (
          <div className="message ai streaming">
            <div className="avatar">🤖</div>
            <div className="content">
              {currentAIMessage}
              <span className="cursor">▊</span>
            </div>
          </div>
        )}
      </div>
      
      <div className="input-area">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
          placeholder="메시지를 입력하세요..."
          disabled={!isConnected}
        />
        <button 
          onClick={sendMessage}
          disabled={!isConnected}
        >
          전송
        </button>
      </div>
    </div>
  );
};
```

### 3. 스타일링
```css
/* ChatInterface.css */
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.connection-status {
  padding: 10px;
  background: #f0f0f0;
  text-align: center;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.message {
  display: flex;
  margin-bottom: 15px;
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message.user {
  flex-direction: row-reverse;
}

.message .avatar {
  font-size: 24px;
  margin: 0 10px;
}

.message .content {
  max-width: 70%;
  padding: 10px 15px;
  border-radius: 15px;
  background: #e0e0e0;
}

.message.user .content {
  background: #007bff;
  color: white;
}

.message.ai.streaming .cursor {
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.input-area {
  display: flex;
  padding: 20px;
  border-top: 1px solid #ddd;
}

.input-area input {
  flex: 1;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 20px;
  margin-right: 10px;
}

.input-area button {
  padding: 10px 20px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 20px;
  cursor: pointer;
}

.input-area button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
```

## 🔄 실시간 통신 흐름

```
1. 사용자가 메시지 입력
        ↓
2. WebSocket으로 서버 전송
        ↓
3. Django Consumer 수신
        ↓
4. 메시지 DB 저장
        ↓
5. AI 모델에 전달
        ↓
6. AI 응답 스트리밍
        ↓
7. 각 청크를 WebSocket으로 전송
        ↓
8. 프론트엔드에서 실시간 표시
        ↓
9. 완료 후 전체 응답 저장
```

## 🚀 고급 기능

### 1. 타이핑 인디케이터
```typescript
// 상대방이 타이핑 중임을 표시
const [isTyping, setIsTyping] = useState(false);

const handleTyping = () => {
  wsService.current.send({
    type: 'typing',
    isTyping: true
  });
  
  // 3초 후 타이핑 중지
  setTimeout(() => {
    wsService.current.send({
      type: 'typing',
      isTyping: false
    });
  }, 3000);
};
```

### 2. 온라인 상태 표시
```python
# Consumer에서 presence 관리
async def connect(self):
    await self.channel_layer.group_send(
        self.room_group_name,
        {
            'type': 'user_join',
            'username': self.scope['user'].username
        }
    )

async def disconnect(self, close_code):
    await self.channel_layer.group_send(
        self.room_group_name,
        {
            'type': 'user_leave',
            'username': self.scope['user'].username
        }
    )
```

### 3. 메시지 읽음 확인
```typescript
// 메시지 읽음 처리
const markAsRead = (messageId: string) => {
  wsService.current.send({
    type: 'read_receipt',
    messageId
  });
};
```

## 📊 성능 최적화

### 1. 메시지 페이지네이션
```typescript
// 무한 스크롤로 이전 메시지 로드
const loadMoreMessages = async () => {
  const olderMessages = await api.get(
    `/messages?before=${oldestMessageId}&limit=20`
  );
  setMessages(prev => [...olderMessages, ...prev]);
};
```

### 2. 디바운싱
```typescript
// 타이핑 이벤트 디바운싱
const debouncedTyping = useMemo(
  () => debounce(handleTyping, 500),
  []
);
```

### 3. 연결 상태 관리
```typescript
// 재연결 로직
const reconnectWithBackoff = (attempt = 1) => {
  const delay = Math.min(1000 * Math.pow(2, attempt), 30000);
  
  setTimeout(() => {
    wsService.connect()
      .catch(() => reconnectWithBackoff(attempt + 1));
  }, delay);
};
```

## 📚 학습 자료

### WebSocket
- [MDN - WebSocket API](https://developer.mozilla.org/ko/docs/Web/API/WebSocket)
- [WebSocket 프로토콜 이해하기](https://tecoble.techcourse.co.kr/post/2021-09-05-web-socket/)

### Django Channels
- [Django Channels 공식 문서](https://channels.readthedocs.io/)
- [Django Channels 튜토리얼](https://realpython.com/getting-started-with-django-channels/)

### 실시간 통신
- [Socket.IO vs WebSocket](https://www.educative.io/answers/socketio-vs-websocket)
- [실시간 웹 기술 가이드](https://www.html5rocks.com/ko/tutorials/websockets/basics/)

## 💡 실습 아이디어

1. **채팅 기능 확장**
   - 이미지/파일 전송
   - 음성 메시지
   - 이모지 반응

2. **실시간 기능 추가**
   - 온라인 사용자 목록
   - 타이핑 인디케이터
   - 읽음 확인

3. **성능 개선**
   - 메시지 캐싱
   - 가상 스크롤링
   - 압축 적용

## 🤔 생각해볼 문제

1. WebSocket vs Server-Sent Events의 차이는?
2. 대규모 채팅 서비스는 어떻게 확장할까?
3. 실시간 통신의 보안 이슈는?

---

다음 문서: [06-AI-모델-통합.md](./06-AI-모델-통합.md) 에서 AI 모델 통합 방법을 알아봐요!