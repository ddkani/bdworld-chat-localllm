# 🎯 실습 가이드 - 직접 해보기!

## 🚀 시작하기 전에

### 필요한 도구들
- **코드 에디터**: VS Code (추천) 또는 다른 에디터
- **터미널**: 명령어 실행용
- **브라우저**: Chrome, Firefox 등
- **Python 3.9+**: 백엔드 실행
- **Node.js 16+**: 프론트엔드 실행

## 📝 실습 1: 환영 메시지 바꾸기 (초급)

### 목표
채팅 시작 시 나타나는 환영 메시지를 수정해봅시다.

### 단계별 가이드

1. **파일 찾기**
```bash
# frontend-chat 폴더로 이동
cd frontend-chat

# ChatInterface 컴포넌트 열기
code src/components/ChatInterface.tsx
```

2. **코드 수정**
```typescript
// 기존 코드
const welcomeMessage = "안녕하세요! 무엇을 도와드릴까요?";

// 수정 후
const welcomeMessage = "👋 안녕하세요! AI 도우미입니다. 궁금한 것을 물어보세요!";
```

3. **결과 확인**
```bash
npm start
# 브라우저에서 http://localhost:3001 접속
```

### 🎓 학습 포인트
- React 컴포넌트의 구조
- 상태(state) 관리
- UI 텍스트 수정 방법

## 📝 실습 2: 채팅 UI 색상 변경 (초급)

### 목표
채팅 메시지의 색상을 커스터마이징해봅시다.

### 단계별 가이드

1. **CSS 파일 열기**
```bash
# ChatInterface.css 파일 열기
code src/components/ChatInterface.css
```

2. **색상 수정**
```css
/* 사용자 메시지 색상 변경 */
.message.user .content {
    background: #4CAF50;  /* 초록색으로 변경 */
    color: white;
}

/* AI 메시지 색상 변경 */
.message.ai .content {
    background: #f0f0f0;  /* 연한 회색 */
    color: #333;
}

/* 입력창 버튼 색상 */
.input-area button {
    background: #4CAF50;  /* 초록색 */
    transition: background 0.3s;
}

.input-area button:hover {
    background: #45a049;  /* 진한 초록색 */
}
```

3. **그라디언트 추가 (보너스)**
```css
.chat-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
}
```

### 🎓 학습 포인트
- CSS 기초
- 색상 시스템 (HEX, RGB)
- 호버 효과
- 그라디언트

## 📝 실습 3: 이모지 피커 추가 (중급)

### 목표
메시지 입력창에 이모지 선택 기능을 추가해봅시다.

### 단계별 가이드

1. **이모지 피커 라이브러리 설치**
```bash
cd frontend-chat
npm install emoji-picker-react
```

2. **컴포넌트 수정**
```typescript
// src/components/ChatInterface.tsx
import EmojiPicker from 'emoji-picker-react';

const ChatInterface: React.FC = () => {
    const [showEmojiPicker, setShowEmojiPicker] = useState(false);
    const [input, setInput] = useState('');
    
    const handleEmojiClick = (emojiData: any) => {
        setInput(prev => prev + emojiData.emoji);
        setShowEmojiPicker(false);
    };
    
    return (
        <div className="chat-container">
            {/* ... 기존 코드 ... */}
            
            <div className="input-area">
                <button 
                    className="emoji-button"
                    onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                >
                    😊
                </button>
                
                {showEmojiPicker && (
                    <div className="emoji-picker-container">
                        <EmojiPicker onEmojiClick={handleEmojiClick} />
                    </div>
                )}
                
                <input
                    type="text"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    placeholder="메시지를 입력하세요..."
                />
                
                <button onClick={sendMessage}>전송</button>
            </div>
        </div>
    );
};
```

3. **스타일 추가**
```css
.emoji-button {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 5px 10px;
}

.emoji-picker-container {
    position: absolute;
    bottom: 60px;
    left: 10px;
}
```

### 🎓 학습 포인트
- npm 패키지 설치 및 사용
- 상태 토글 (show/hide)
- 이벤트 핸들링
- 절대 위치 지정

## 📝 실습 4: 메시지 복사 버튼 추가 (중급)

### 목표
각 메시지에 복사 버튼을 추가해봅시다.

### 단계별 가이드

1. **복사 기능 구현**
```typescript
// src/components/MessageItem.tsx
import React, { useState } from 'react';
import { ContentCopy, Check } from '@mui/icons-material';

interface MessageItemProps {
    content: string;
    isUser: boolean;
    timestamp: Date;
}

const MessageItem: React.FC<MessageItemProps> = ({ content, isUser }) => {
    const [copied, setCopied] = useState(false);
    
    const handleCopy = async () => {
        try {
            await navigator.clipboard.writeText(content);
            setCopied(true);
            
            // 2초 후 아이콘 원래대로
            setTimeout(() => setCopied(false), 2000);
        } catch (err) {
            console.error('복사 실패:', err);
        }
    };
    
    return (
        <div className={`message ${isUser ? 'user' : 'ai'}`}>
            <div className="avatar">
                {isUser ? '👤' : '🤖'}
            </div>
            <div className="content">
                {content}
                <button 
                    className="copy-button"
                    onClick={handleCopy}
                    title="복사"
                >
                    {copied ? <Check /> : <ContentCopy />}
                </button>
            </div>
        </div>
    );
};
```

2. **스타일 추가**
```css
.message .content {
    position: relative;
    padding-right: 40px;
}

.copy-button {
    position: absolute;
    top: 5px;
    right: 5px;
    background: none;
    border: none;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.3s;
}

.message:hover .copy-button {
    opacity: 0.7;
}

.copy-button:hover {
    opacity: 1 !important;
}
```

### 🎓 학습 포인트
- Clipboard API 사용
- 조건부 렌더링
- setTimeout 활용
- Material-UI 아이콘

## 📝 실습 5: AI 프롬프트 커스터마이징 (고급)

### 목표
AI의 성격과 응답 스타일을 변경해봅시다.

### 단계별 가이드

1. **프롬프트 템플릿 생성**
```python
# backend/llm/prompt_templates.py
PERSONALITY_TEMPLATES = {
    'friendly': {
        'name': '친근한 도우미',
        'system': """당신은 매우 친근하고 따뜻한 AI 도우미입니다.
        이모지를 자주 사용하고, 격식없이 편하게 대화합니다.
        '~요', '~네요' 같은 부드러운 어미를 사용합니다.""",
        'temperature': 0.8
    },
    
    'professional': {
        'name': '전문 비서',
        'system': """당신은 전문적이고 정확한 AI 비서입니다.
        정중하고 격식있는 언어를 사용합니다.
        필요한 정보를 체계적으로 정리해서 제공합니다.""",
        'temperature': 0.5
    },
    
    'teacher': {
        'name': '선생님',
        'system': """당신은 친절한 선생님입니다.
        복잡한 개념을 쉽게 설명하고, 예시를 들어줍니다.
        학생이 이해했는지 확인하는 질문도 합니다.""",
        'temperature': 0.7
    },
    
    'coder': {
        'name': '코딩 도우미',
        'system': """당신은 프로그래밍 전문가입니다.
        코드는 항상 ```언어명 으로 감싸서 제공합니다.
        주석을 충분히 달고, 모범 사례를 따릅니다.""",
        'temperature': 0.3
    }
}
```

2. **API 엔드포인트 추가**
```python
# backend/llm/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['GET'])
def get_personalities(request):
    """사용 가능한 성격 목록"""
    personalities = [
        {
            'id': key,
            'name': value['name'],
            'description': value['system'][:100] + '...'
        }
        for key, value in PERSONALITY_TEMPLATES.items()
    ]
    return Response(personalities)

@api_view(['POST'])
def set_personality(request):
    """세션의 AI 성격 설정"""
    session_id = request.data.get('session_id')
    personality = request.data.get('personality', 'friendly')
    
    # 세션에 성격 저장
    session = ChatSession.objects.get(id=session_id)
    session.ai_personality = personality
    session.save()
    
    return Response({'status': 'success'})
```

3. **프론트엔드 선택 UI**
```typescript
// src/components/PersonalitySelector.tsx
const PersonalitySelector: React.FC = () => {
    const [personalities, setPersonalities] = useState([]);
    const [selected, setSelected] = useState('friendly');
    
    useEffect(() => {
        // API에서 성격 목록 가져오기
        api.get('/llm/personalities/')
            .then(res => setPersonalities(res.data));
    }, []);
    
    const handleChange = (personality: string) => {
        setSelected(personality);
        api.post('/llm/set-personality/', {
            session_id: currentSession,
            personality
        });
    };
    
    return (
        <div className="personality-selector">
            <h3>AI 성격 선택</h3>
            <div className="personality-options">
                {personalities.map(p => (
                    <div 
                        key={p.id}
                        className={`personality-card ${
                            selected === p.id ? 'selected' : ''
                        }`}
                        onClick={() => handleChange(p.id)}
                    >
                        <h4>{p.name}</h4>
                        <p>{p.description}</p>
                    </div>
                ))}
            </div>
        </div>
    );
};
```

### 🎓 학습 포인트
- 프롬프트 엔지니어링
- API 설계
- 상태 관리
- 동적 UI 업데이트

## 📝 실습 6: 타이핑 애니메이션 추가 (고급)

### 목표
AI가 응답하는 동안 타이핑 애니메이션을 표시해봅시다.

### 단계별 가이드

1. **타이핑 인디케이터 컴포넌트**
```typescript
// src/components/TypingIndicator.tsx
const TypingIndicator: React.FC = () => {
    return (
        <div className="typing-indicator">
            <div className="typing-dot"></div>
            <div className="typing-dot"></div>
            <div className="typing-dot"></div>
        </div>
    );
};
```

2. **CSS 애니메이션**
```css
.typing-indicator {
    display: flex;
    align-items: center;
    padding: 10px;
}

.typing-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #999;
    margin: 0 3px;
    animation: typing 1.4s infinite;
}

.typing-dot:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typing {
    0%, 60%, 100% {
        transform: translateY(0);
    }
    30% {
        transform: translateY(-10px);
    }
}
```

3. **채팅 인터페이스에 통합**
```typescript
const ChatInterface: React.FC = () => {
    const [isAITyping, setIsAITyping] = useState(false);
    
    // WebSocket 메시지 핸들러
    useEffect(() => {
        wsService.onMessage((data) => {
            if (data.type === 'ai_start') {
                setIsAITyping(true);
            } else if (data.type === 'ai_complete') {
                setIsAITyping(false);
            }
        });
    }, []);
    
    return (
        <div className="messages">
            {messages.map(msg => (
                <MessageItem key={msg.id} {...msg} />
            ))}
            
            {isAITyping && (
                <div className="message ai">
                    <div className="avatar">🤖</div>
                    <TypingIndicator />
                </div>
            )}
        </div>
    );
};
```

### 🎓 학습 포인트
- CSS 애니메이션
- 컴포넌트 재사용
- 상태 기반 렌더링
- WebSocket 이벤트 처리

## 📝 실습 7: 음성 입력 기능 (고급)

### 목표
음성으로 메시지를 입력할 수 있게 해봅시다.

### 단계별 가이드

1. **음성 인식 Hook 생성**
```typescript
// src/hooks/useSpeechRecognition.ts
import { useState, useEffect } from 'react';

const useSpeechRecognition = () => {
    const [isListening, setIsListening] = useState(false);
    const [transcript, setTranscript] = useState('');
    
    useEffect(() => {
        // Web Speech API 확인
        if (!('webkitSpeechRecognition' in window)) {
            console.error('음성 인식 미지원');
            return;
        }
        
        const recognition = new (window as any).webkitSpeechRecognition();
        recognition.lang = 'ko-KR';
        recognition.continuous = true;
        recognition.interimResults = true;
        
        recognition.onresult = (event: any) => {
            let finalTranscript = '';
            
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcript;
                }
            }
            
            if (finalTranscript) {
                setTranscript(finalTranscript);
            }
        };
        
        if (isListening) {
            recognition.start();
        } else {
            recognition.stop();
        }
        
        return () => {
            recognition.stop();
        };
    }, [isListening]);
    
    return {
        isListening,
        transcript,
        startListening: () => setIsListening(true),
        stopListening: () => setIsListening(false)
    };
};
```

2. **UI에 통합**
```typescript
import { Mic, MicOff } from '@mui/icons-material';

const ChatInterface: React.FC = () => {
    const { isListening, transcript, startListening, stopListening } = useSpeechRecognition();
    const [input, setInput] = useState('');
    
    useEffect(() => {
        if (transcript) {
            setInput(prev => prev + ' ' + transcript);
        }
    }, [transcript]);
    
    return (
        <div className="input-area">
            <button 
                className={`voice-button ${isListening ? 'listening' : ''}`}
                onClick={isListening ? stopListening : startListening}
            >
                {isListening ? <Mic /> : <MicOff />}
            </button>
            
            <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder={isListening ? "말씀하세요..." : "메시지를 입력하세요..."}
            />
            
            <button onClick={sendMessage}>전송</button>
        </div>
    );
};
```

3. **스타일 추가**
```css
.voice-button {
    background: #f0f0f0;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    transition: all 0.3s;
}

.voice-button.listening {
    background: #ff4444;
    color: white;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(255, 68, 68, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(255, 68, 68, 0);
    }
}
```

### 🎓 학습 포인트
- Web Speech API
- Custom Hooks
- 실시간 상태 업데이트
- 애니메이션 효과

## 🚀 도전 과제

### 1. 메시지 검색 기능 (⭐⭐)
- 대화 내역에서 키워드 검색
- 검색 결과 하이라이트
- 검색 결과로 스크롤

### 2. 다크 모드 구현 (⭐⭐⭐)
- 테마 전환 버튼
- localStorage에 설정 저장
- CSS 변수 활용

### 3. 파일 업로드 (⭐⭐⭐⭐)
- 이미지 업로드 및 미리보기
- PDF 문서 업로드
- AI가 파일 내용 분석

### 4. 멀티 언어 지원 (⭐⭐⭐⭐⭐)
- i18n 라이브러리 통합
- 언어 선택 UI
- 번역 파일 관리

## 📚 추가 학습 자료

### 온라인 코스
- [생활코딩 WEB](https://opentutorials.org/course/3084)
- [노마드코더 무료 강의](https://nomadcoders.co/)
- [인프런 무료 강의](https://www.inflearn.com/courses?s=무료)

### 유튜브 채널
- [드림코딩](https://www.youtube.com/c/드림코딩by엘리)
- [코딩애플](https://www.youtube.com/channel/UCSLrpBAzr-ROVGHQ5EmxnUg)
- [노마드 코더](https://www.youtube.com/c/노마드코더NomadCoders)

### 연습 사이트
- [CodePen](https://codepen.io/) - 웹 코드 실험
- [CodeSandbox](https://codesandbox.io/) - 온라인 IDE
- [Replit](https://replit.com/) - 협업 코딩

## 🎯 다음 단계

1. **Git 사용법 익히기**
   - 버전 관리
   - 브랜치 전략
   - Pull Request

2. **테스트 코드 작성**
   - 단위 테스트
   - 통합 테스트
   - E2E 테스트

3. **성능 최적화**
   - React 메모이제이션
   - 코드 스플리팅
   - 번들 크기 줄이기

4. **배포하기**
   - Vercel/Netlify (프론트엔드)
   - Heroku/Railway (백엔드)
   - Docker 컨테이너화

---

이제 여러분이 직접 코드를 수정하고 실험해볼 차례입니다! 🚀
궁금한 점이 있다면 언제든 문서를 참고하거나 커뮤니티에 질문하세요.