# ğŸ—ï¸ í”„ë¡œì íŠ¸ êµ¬ì¡° ì‹¬í™” ë¶„ì„

## ğŸ“š ëª©ì°¨
1. [í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜ ì „ì²´ ë¶„ì„](#í”„ë¡œì íŠ¸-ì•„í‚¤í…ì²˜-ì „ì²´-ë¶„ì„)
2. [ë°±ì—”ë“œ ìƒì„¸ êµ¬ì¡°](#ë°±ì—”ë“œ-ìƒì„¸-êµ¬ì¡°)
3. [í”„ë¡ íŠ¸ì—”ë“œ ìƒì„¸ êµ¬ì¡°](#í”„ë¡ íŠ¸ì—”ë“œ-ìƒì„¸-êµ¬ì¡°)
4. [ë°ì´í„° í”Œë¡œìš° ë¶„ì„](#ë°ì´í„°-í”Œë¡œìš°-ë¶„ì„)
5. [í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜](#í™•ì¥ì„±ê³¼-ìœ ì§€ë³´ìˆ˜)

---

## ğŸ¯ í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜ ì „ì²´ ë¶„ì„

### ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ê°œìš”
```mermaid
graph TB
    subgraph "Client Layer"
        USER[ì‚¬ìš©ì]
        ADMIN[ê´€ë¦¬ì]
    end
    
    subgraph "Presentation Layer"
        CHAT_UI[ì±„íŒ… UI<br/>React + TypeScript]
        ADMIN_UI[ê´€ë¦¬ì UI<br/>React + TypeScript]
    end
    
    subgraph "API Gateway"
        NGINX[Nginx<br/>Reverse Proxy]
    end
    
    subgraph "Application Layer"
        DJANGO[Django Server]
        CHANNELS[Django Channels<br/>WebSocket]
        DRF[Django REST Framework]
    end
    
    subgraph "Service Layer"
        AUTH_SVC[ì¸ì¦ ì„œë¹„ìŠ¤]
        CHAT_SVC[ì±„íŒ… ì„œë¹„ìŠ¤]
        LLM_SVC[LLM ì„œë¹„ìŠ¤]
        RAG_SVC[RAG ì„œë¹„ìŠ¤]
    end
    
    subgraph "Data Layer"
        SQLITE[(SQLite DB)]
        CHROMA[(ChromaDB<br/>Vector Store)]
        REDIS[(Redis<br/>Cache/Channel)]
        FILES[Model Files<br/>GGUF]
    end
    
    USER --> CHAT_UI
    ADMIN --> ADMIN_UI
    
    CHAT_UI --> NGINX
    ADMIN_UI --> NGINX
    
    NGINX --> DJANGO
    NGINX --> CHANNELS
    
    DJANGO --> DRF
    DRF --> AUTH_SVC
    DRF --> CHAT_SVC
    
    CHANNELS --> CHAT_SVC
    CHAT_SVC --> LLM_SVC
    LLM_SVC --> RAG_SVC
    
    AUTH_SVC --> SQLITE
    CHAT_SVC --> SQLITE
    CHAT_SVC --> REDIS
    RAG_SVC --> CHROMA
    LLM_SVC --> FILES
```

### ë””ë ‰í„°ë¦¬ êµ¬ì¡° ë¶„ì„
```
bdworld-chat-codefair/
â”œâ”€â”€ ğŸ“ backend/                 # ë°±ì—”ë“œ ë£¨íŠ¸
â”‚   â”œâ”€â”€ ğŸ“ chat_project/       # Django í”„ë¡œì íŠ¸ ì„¤ì •
â”‚   â”‚   â”œâ”€â”€ settings.py        # ì „ì—­ ì„¤ì •
â”‚   â”‚   â”œâ”€â”€ urls.py           # URL ë¼ìš°íŒ…
â”‚   â”‚   â”œâ”€â”€ asgi.py           # ASGI ì„¤ì • (WebSocket)
â”‚   â”‚   â””â”€â”€ wsgi.py           # WSGI ì„¤ì • (HTTP)
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ chat/               # ì±„íŒ… ì•± (ë„ë©”ì¸)
â”‚   â”‚   â”œâ”€â”€ models.py         # ë°ì´í„° ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ views.py          # API ë·°
â”‚   â”‚   â”œâ”€â”€ serializers.py    # ì§ë ¬í™”
â”‚   â”‚   â”œâ”€â”€ consumers.py      # WebSocket í•¸ë“¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ routing.py        # WebSocket ë¼ìš°íŒ…
â”‚   â”‚   â””â”€â”€ tests/            # í…ŒìŠ¤íŠ¸
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ llm/                # AI ëª¨ë¸ ì•± (ë„ë©”ì¸)
â”‚   â”‚   â”œâ”€â”€ llm_service.py    # LLM ì„œë¹„ìŠ¤ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ models.py         # AI ê´€ë ¨ ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ views.py          # AI API
â”‚   â”‚   â””â”€â”€ management/       # ê´€ë¦¬ ëª…ë ¹ì–´
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ models/             # AI ëª¨ë¸ íŒŒì¼
â”‚   â”œâ”€â”€ ğŸ“ datasets/           # í•™ìŠµ ë°ì´í„°
â”‚   â””â”€â”€ manage.py             # Django ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸
â”‚
â”œâ”€â”€ ğŸ“ frontend-chat/          # ì±„íŒ… í”„ë¡ íŠ¸ì—”ë“œ
â”‚   â”œâ”€â”€ ğŸ“ src/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ components/    # UI ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”œâ”€â”€ ğŸ“ services/      # API ì„œë¹„ìŠ¤
â”‚   â”‚   â”œâ”€â”€ ğŸ“ contexts/      # React Context
â”‚   â”‚   â””â”€â”€ ğŸ“ types/         # TypeScript íƒ€ì…
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ public/            # ì •ì  íŒŒì¼
â”‚
â””â”€â”€ ğŸ“ frontend-admin/         # ê´€ë¦¬ì í”„ë¡ íŠ¸ì—”ë“œ
    â””â”€â”€ ğŸ“ src/
        â”œâ”€â”€ ğŸ“ pages/         # í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸
        â””â”€â”€ ğŸ“ components/    # ê³µí†µ ì»´í¬ë„ŒíŠ¸
```

## ğŸ”§ ë°±ì—”ë“œ ìƒì„¸ êµ¬ì¡°

### Django ì•± êµ¬ì¡°ì™€ ì±…ì„
```python
# ê° ì•±ì˜ ì±…ì„ê³¼ ì—­í• 

# 1. chat ì•± - ì±„íŒ… ë„ë©”ì¸
"""
ì±…ì„:
- ì±„íŒ… ì„¸ì…˜ ê´€ë¦¬
- ë©”ì‹œì§€ ì €ì¥ ë° ì¡°íšŒ
- ì‹¤ì‹œê°„ í†µì‹  ì²˜ë¦¬
- ì‚¬ìš©ì ì¸ì¦
"""

# 2. llm ì•± - AI ë„ë©”ì¸
"""
ì±…ì„:
- LLM ëª¨ë¸ ë¡œë“œ ë° ê´€ë¦¬
- í…ìŠ¤íŠ¸ ìƒì„±
- í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ê´€ë¦¬
- RAG í†µí•©
- Fine-tuning
"""
```

### ëª¨ë¸ ê³„ì¸µ êµ¬ì¡°
```python
# backend/chat/models.py
from django.db import models
from django.contrib.auth.models import AbstractUser

# ë„ë©”ì¸ ëª¨ë¸ ì •ì˜
class User(AbstractUser):
    """í™•ì¥ëœ ì‚¬ìš©ì ëª¨ë¸"""
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'users'

class ChatSession(models.Model):
    """ì±„íŒ… ì„¸ì…˜ - Aggregate Root"""
    title = models.CharField(max_length=200)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    def add_message(self, content: str, is_user: bool):
        """ë©”ì‹œì§€ ì¶”ê°€"""
        return self.messages.create(
            content=content,
            is_user=is_user
        )
    
    def get_context(self, limit: int = 10):
        """ìµœê·¼ ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ë°˜í™˜"""
        messages = self.messages.order_by('-timestamp')[:limit]
        return list(reversed(messages))
    
    class Meta:
        db_table = 'chat_sessions'
        ordering = ['-created_at']

class Message(models.Model):
    """ë©”ì‹œì§€ - Entity"""
    session = models.ForeignKey(
        ChatSession,
        on_delete=models.CASCADE,
        related_name='messages'
    )
    content = models.TextField()
    is_user = models.BooleanField(default=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    
    # ë©”íƒ€ë°ì´í„°
    token_count = models.IntegerField(null=True)
    processing_time = models.FloatField(null=True)
    
    class Meta:
        db_table = 'messages'
        indexes = [
            models.Index(fields=['session', '-timestamp']),
        ]
```

### ì„œë¹„ìŠ¤ ê³„ì¸µ íŒ¨í„´
```python
# backend/chat/services.py
from typing import Optional, List
from django.db import transaction
from .models import ChatSession, Message
from llm.llm_service import LLMService

class ChatService:
    """ì±„íŒ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§"""
    
    def __init__(self):
        self.llm_service = LLMService()
    
    @transaction.atomic
    def create_session(self, user, title: str) -> ChatSession:
        """ìƒˆ ì±„íŒ… ì„¸ì…˜ ìƒì„±"""
        session = ChatSession.objects.create(
            user=user,
            title=title
        )
        
        # ì´ˆê¸° ì‹œìŠ¤í…œ ë©”ì‹œì§€
        session.add_message(
            content="ì•ˆë…•í•˜ì„¸ìš”! ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
            is_user=False
        )
        
        return session
    
    async def process_message(
        self,
        session: ChatSession,
        user_message: str
    ) -> AsyncGenerator[str, None]:
        """ë©”ì‹œì§€ ì²˜ë¦¬ ë° AI ì‘ë‹µ ìƒì„±"""
        
        # 1. ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥
        user_msg = session.add_message(
            content=user_message,
            is_user=True
        )
        
        # 2. ì»¨í…ìŠ¤íŠ¸ ì¤€ë¹„
        context = self._prepare_context(session)
        
        # 3. AI ì‘ë‹µ ìƒì„± (ìŠ¤íŠ¸ë¦¬ë°)
        ai_response = ""
        async for chunk in self.llm_service.generate_stream(
            prompt=user_message,
            context=context
        ):
            ai_response += chunk
            yield chunk
        
        # 4. AI ì‘ë‹µ ì €ì¥
        ai_msg = session.add_message(
            content=ai_response,
            is_user=False
        )
        
        # 5. ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
        ai_msg.token_count = self.llm_service.count_tokens(ai_response)
        ai_msg.save()
    
    def _prepare_context(self, session: ChatSession) -> str:
        """ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ì¤€ë¹„"""
        messages = session.get_context(limit=10)
        
        context = ""
        for msg in messages:
            role = "User" if msg.is_user else "Assistant"
            context += f"{role}: {msg.content}\n\n"
        
        return context
```

### API ë·° êµ¬ì¡°
```python
# backend/chat/views.py
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from .models import ChatSession
from .serializers import ChatSessionSerializer
from .services import ChatService

class ChatSessionViewSet(viewsets.ModelViewSet):
    """ì±„íŒ… ì„¸ì…˜ API"""
    serializer_class = ChatSessionSerializer
    permission_classes = [IsAuthenticated]
    service = ChatService()
    
    def get_queryset(self):
        """ì‚¬ìš©ìë³„ ì„¸ì…˜ í•„í„°ë§"""
        return ChatSession.objects.filter(
            user=self.request.user
        ).prefetch_related('messages')
    
    def perform_create(self, serializer):
        """ì„¸ì…˜ ìƒì„±"""
        session = self.service.create_session(
            user=self.request.user,
            title=serializer.validated_data['title']
        )
        serializer.instance = session
    
    @action(detail=True, methods=['post'])
    def clear_messages(self, request, pk=None):
        """ë©”ì‹œì§€ ì´ˆê¸°í™”"""
        session = self.get_object()
        session.messages.all().delete()
        return Response({'status': 'cleared'})
    
    @action(detail=True, methods=['get'])
    def export(self, request, pk=None):
        """ëŒ€í™” ë‚´ë³´ë‚´ê¸°"""
        session = self.get_object()
        messages = session.messages.values(
            'content', 'is_user', 'timestamp'
        )
        
        return Response({
            'session': session.title,
            'messages': list(messages)
        })
```

### WebSocket Consumer êµ¬ì¡°
```python
# backend/chat/consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from .services import ChatService

class ChatConsumer(AsyncWebsocketConsumer):
    """WebSocket ì±„íŒ… í•¸ë“¤ëŸ¬"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.session_id = None
        self.room_group_name = None
        self.service = ChatService()
    
    async def connect(self):
        """ì—°ê²° ìˆ˜ë¦½"""
        # URLì—ì„œ ì„¸ì…˜ ID ì¶”ì¶œ
        self.session_id = self.scope['url_route']['kwargs']['session_id']
        self.room_group_name = f'chat_{self.session_id}'
        
        # ê¶Œí•œ í™•ì¸
        if not await self.check_permission():
            await self.close()
            return
        
        # ì±„ë„ ê·¸ë£¹ ì°¸ê°€
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # ì—°ê²° ë©”ì‹œì§€
        await self.send_json({
            'type': 'connection',
            'message': 'ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤'
        })
    
    async def receive_json(self, content):
        """ë©”ì‹œì§€ ìˆ˜ì‹ """
        message_type = content.get('type')
        
        if message_type == 'chat_message':
            await self.handle_chat_message(content)
        elif message_type == 'typing':
            await self.handle_typing(content)
    
    async def handle_chat_message(self, content):
        """ì±„íŒ… ë©”ì‹œì§€ ì²˜ë¦¬"""
        user_message = content['message']
        
        # ì‚¬ìš©ì ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': user_message,
                'is_user': True
            }
        )
        
        # AI ì‘ë‹µ ìƒì„± (ìŠ¤íŠ¸ë¦¬ë°)
        session = await self.get_session()
        
        async for chunk in self.service.process_message(
            session,
            user_message
        ):
            # ê° ì²­í¬ ì „ì†¡
            await self.send_json({
                'type': 'ai_chunk',
                'chunk': chunk
            })
        
        # ì™„ë£Œ ì‹ í˜¸
        await self.send_json({
            'type': 'ai_complete'
        })
    
    @database_sync_to_async
    def get_session(self):
        """ì„¸ì…˜ ì¡°íšŒ"""
        from .models import ChatSession
        return ChatSession.objects.get(id=self.session_id)
    
    @database_sync_to_async
    def check_permission(self):
        """ê¶Œí•œ í™•ì¸"""
        user = self.scope['user']
        if not user.is_authenticated:
            return False
        
        from .models import ChatSession
        return ChatSession.objects.filter(
            id=self.session_id,
            user=user
        ).exists()
```

## ğŸ’» í”„ë¡ íŠ¸ì—”ë“œ ìƒì„¸ êµ¬ì¡°

### ì»´í¬ë„ŒíŠ¸ ì•„í‚¤í…ì²˜
```typescript
// frontend-chat/src/components/architecture.ts

// 1. Presentational Components (UI)
// ìˆœìˆ˜í•œ UI ë Œë”ë§ë§Œ ë‹´ë‹¹
interface ButtonProps {
    label: string;
    onClick: () => void;
    variant?: 'primary' | 'secondary';
}

const Button: React.FC<ButtonProps> = ({ label, onClick, variant = 'primary' }) => {
    return (
        <button className={`btn btn-${variant}`} onClick={onClick}>
            {label}
        </button>
    );
};

// 2. Container Components (Logic)
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ê³¼ ìƒíƒœ ê´€ë¦¬
const ChatContainer: React.FC = () => {
    const [messages, setMessages] = useState<Message[]>([]);
    const { user } = useAuth();
    const ws = useWebSocket();
    
    const sendMessage = (content: string) => {
        ws.send({ type: 'chat_message', message: content });
    };
    
    return (
        <ChatInterface
            messages={messages}
            onSendMessage={sendMessage}
            currentUser={user}
        />
    );
};

// 3. Higher-Order Components (HOC)
// ì»´í¬ë„ŒíŠ¸ ê¸°ëŠ¥ í™•ì¥
const withAuth = <P extends object>(
    Component: React.ComponentType<P>
): React.FC<P> => {
    return (props: P) => {
        const { isAuthenticated } = useAuth();
        
        if (!isAuthenticated) {
            return <Navigate to="/login" />;
        }
        
        return <Component {...props} />;
    };
};

// 4. Custom Hooks
// ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë¡œì§
const useChat = (sessionId: string) => {
    const [messages, setMessages] = useState<Message[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    
    useEffect(() => {
        fetchMessages(sessionId)
            .then(setMessages)
            .catch(err => setError(err.message));
    }, [sessionId]);
    
    return { messages, loading, error };
};
```

### ìƒíƒœ ê´€ë¦¬ íŒ¨í„´
```typescript
// frontend-chat/src/store/index.ts

// 1. Context API íŒ¨í„´
interface AppState {
    user: User | null;
    sessions: ChatSession[];
    currentSession: ChatSession | null;
}

const AppContext = createContext<{
    state: AppState;
    dispatch: Dispatch<AppAction>;
}>({
    state: initialState,
    dispatch: () => null
});

// 2. Reducer íŒ¨í„´
type AppAction =
    | { type: 'SET_USER'; payload: User }
    | { type: 'ADD_SESSION'; payload: ChatSession }
    | { type: 'SELECT_SESSION'; payload: string }
    | { type: 'ADD_MESSAGE'; payload: Message };

function appReducer(state: AppState, action: AppAction): AppState {
    switch (action.type) {
        case 'SET_USER':
            return { ...state, user: action.payload };
        
        case 'ADD_SESSION':
            return {
                ...state,
                sessions: [...state.sessions, action.payload]
            };
        
        case 'SELECT_SESSION':
            return {
                ...state,
                currentSession: state.sessions.find(
                    s => s.id === action.payload
                ) || null
            };
        
        case 'ADD_MESSAGE':
            if (!state.currentSession) return state;
            
            return {
                ...state,
                currentSession: {
                    ...state.currentSession,
                    messages: [
                        ...state.currentSession.messages,
                        action.payload
                    ]
                }
            };
        
        default:
            return state;
    }
}

// 3. Custom Hook for State
const useAppState = () => {
    const context = useContext(AppContext);
    
    if (!context) {
        throw new Error('useAppState must be used within AppProvider');
    }
    
    return context;
};
```

### ì„œë¹„ìŠ¤ ë ˆì´ì–´
```typescript
// frontend-chat/src/services/api.service.ts

class APIService {
    private baseURL: string;
    private token: string | null;
    
    constructor() {
        this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';
        this.token = localStorage.getItem('auth_token');
    }
    
    // HTTP ì¸í„°ì…‰í„°
    private async request<T>(
        url: string,
        options: RequestInit = {}
    ): Promise<T> {
        const headers = {
            'Content-Type': 'application/json',
            ...(this.token && { 'Authorization': `Token ${this.token}` }),
            ...options.headers
        };
        
        try {
            const response = await fetch(`${this.baseURL}${url}`, {
                ...options,
                headers
            });
            
            if (!response.ok) {
                throw new APIError(response.status, await response.text());
            }
            
            return await response.json();
        } catch (error) {
            this.handleError(error);
            throw error;
        }
    }
    
    // ì—ëŸ¬ ì²˜ë¦¬
    private handleError(error: any) {
        if (error.status === 401) {
            // í† í° ë§Œë£Œ - ì¬ë¡œê·¸ì¸
            this.logout();
        } else if (error.status === 429) {
            // Rate limiting
            console.error('Too many requests');
        }
    }
    
    // API ë©”ì„œë“œ
    async login(username: string): Promise<AuthResponse> {
        const response = await this.request<AuthResponse>('/auth/login/', {
            method: 'POST',
            body: JSON.stringify({ username })
        });
        
        this.token = response.token;
        localStorage.setItem('auth_token', response.token);
        
        return response;
    }
    
    async getSessions(): Promise<ChatSession[]> {
        return this.request<ChatSession[]>('/sessions/');
    }
    
    async createSession(title: string): Promise<ChatSession> {
        return this.request<ChatSession>('/sessions/', {
            method: 'POST',
            body: JSON.stringify({ title })
        });
    }
}

// Singleton íŒ¨í„´
export default new APIService();
```

## ğŸ”„ ë°ì´í„° í”Œë¡œìš° ë¶„ì„

### ë©”ì‹œì§€ ì „ì†¡ í”Œë¡œìš°
```mermaid
sequenceDiagram
    participant U as User
    participant UI as React UI
    participant WS as WebSocket
    participant C as Consumer
    participant S as Service
    participant LLM as LLM Service
    participant DB as Database
    
    U->>UI: ë©”ì‹œì§€ ì…ë ¥
    UI->>UI: ì…ë ¥ ê²€ì¦
    UI->>WS: send(message)
    WS->>C: receive_json()
    
    C->>DB: ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥
    C->>S: process_message()
    
    S->>LLM: generate_stream()
    
    loop ìŠ¤íŠ¸ë¦¬ë°
        LLM->>S: yield chunk
        S->>C: yield chunk
        C->>WS: send_json(chunk)
        WS->>UI: onMessage(chunk)
        UI->>U: í™”ë©´ ì—…ë°ì´íŠ¸
    end
    
    S->>DB: AI ì‘ë‹µ ì €ì¥
    C->>WS: send_json(complete)
    WS->>UI: onComplete()
```

### ìƒíƒœ ë™ê¸°í™” íŒ¨í„´
```typescript
// ë¡œì»¬ ìƒíƒœì™€ ì„œë²„ ìƒíƒœ ë™ê¸°í™”
class StateSync {
    private localState: Map<string, any> = new Map();
    private pendingSync: Set<string> = new Set();
    
    // Optimistic Update
    async updateOptimistic<T>(
        key: string,
        value: T,
        syncFn: () => Promise<T>
    ): Promise<T> {
        // 1. ë¡œì»¬ ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        this.localState.set(key, value);
        this.notifySubscribers(key, value);
        
        // 2. ì„œë²„ ë™ê¸°í™” í‘œì‹œ
        this.pendingSync.add(key);
        
        try {
            // 3. ì„œë²„ ë™ê¸°í™”
            const serverValue = await syncFn();
            
            // 4. ì„œë²„ ì‘ë‹µìœ¼ë¡œ ì—…ë°ì´íŠ¸
            this.localState.set(key, serverValue);
            this.pendingSync.delete(key);
            this.notifySubscribers(key, serverValue);
            
            return serverValue;
        } catch (error) {
            // 5. ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
            this.localState.delete(key);
            this.pendingSync.delete(key);
            this.notifySubscribers(key, null);
            throw error;
        }
    }
    
    private notifySubscribers(key: string, value: any) {
        // Observer íŒ¨í„´ìœ¼ë¡œ êµ¬ë…ìì—ê²Œ ì•Œë¦¼
        this.subscribers.get(key)?.forEach(callback => {
            callback(value);
        });
    }
}
```

## ğŸ”§ í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜

### ëª¨ë“ˆí™” ì „ëµ
```python
# backend/core/base.py
# ê³µí†µ ê¸°ëŠ¥ ì¶”ìƒí™”

from abc import ABC, abstractmethod
from typing import Generic, TypeVar, List, Optional

T = TypeVar('T')

class BaseRepository(ABC, Generic[T]):
    """ë¦¬í¬ì§€í† ë¦¬ íŒ¨í„´"""
    
    @abstractmethod
    async def get(self, id: int) -> Optional[T]:
        pass
    
    @abstractmethod
    async def list(self, **filters) -> List[T]:
        pass
    
    @abstractmethod
    async def create(self, data: dict) -> T:
        pass
    
    @abstractmethod
    async def update(self, id: int, data: dict) -> T:
        pass
    
    @abstractmethod
    async def delete(self, id: int) -> bool:
        pass

class BaseService(ABC):
    """ì„œë¹„ìŠ¤ íŒ¨í„´"""
    
    def __init__(self, repository: BaseRepository):
        self.repository = repository
    
    async def execute(self, *args, **kwargs):
        """í…œí”Œë¦¿ ë©”ì„œë“œ íŒ¨í„´"""
        self.validate(*args, **kwargs)
        result = await self.process(*args, **kwargs)
        await self.post_process(result)
        return result
    
    @abstractmethod
    def validate(self, *args, **kwargs):
        pass
    
    @abstractmethod
    async def process(self, *args, **kwargs):
        pass
    
    async def post_process(self, result):
        """í›„ì²˜ë¦¬ - ì„ íƒì  ì˜¤ë²„ë¼ì´ë“œ"""
        pass
```

### í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜
```python
# backend/plugins/base.py
class PluginBase:
    """í”ŒëŸ¬ê·¸ì¸ ì¸í„°í˜ì´ìŠ¤"""
    
    name: str = "Base Plugin"
    version: str = "1.0.0"
    
    def initialize(self, app):
        """í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™”"""
        pass
    
    def process_message(self, message: str) -> str:
        """ë©”ì‹œì§€ ì²˜ë¦¬ í›…"""
        return message
    
    def cleanup(self):
        """ì •ë¦¬ ì‘ì—…"""
        pass

# backend/plugins/manager.py
class PluginManager:
    """í”ŒëŸ¬ê·¸ì¸ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.plugins: List[PluginBase] = []
    
    def register(self, plugin: PluginBase):
        """í”ŒëŸ¬ê·¸ì¸ ë“±ë¡"""
        self.plugins.append(plugin)
        plugin.initialize(self)
    
    def process_message(self, message: str) -> str:
        """ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ì—ì„œ ë©”ì‹œì§€ ì²˜ë¦¬"""
        for plugin in self.plugins:
            message = plugin.process_message(message)
        return message

# ì‚¬ìš© ì˜ˆ
from plugins.translation import TranslationPlugin
from plugins.moderation import ModerationPlugin

manager = PluginManager()
manager.register(TranslationPlugin())
manager.register(ModerationPlugin())
```

### ì„±ëŠ¥ ìµœì í™” ì „ëµ
```python
# 1. ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
from django.db.models import Prefetch, Count, Q

class OptimizedQuerySet:
    @staticmethod
    def get_sessions_with_messages(user):
        """N+1 ë¬¸ì œ í•´ê²°"""
        return ChatSession.objects.filter(user=user)\
            .select_related('user')\
            .prefetch_related(
                Prefetch(
                    'messages',
                    queryset=Message.objects.order_by('-timestamp')[:50]
                )
            )\
            .annotate(
                message_count=Count('messages'),
                unread_count=Count('messages', filter=Q(messages__is_read=False))
            )

# 2. ìºì‹± ì „ëµ
from django.core.cache import cache
from functools import wraps

def cache_result(timeout=300):
    """ê²°ê³¼ ìºì‹± ë°ì½”ë ˆì´í„°"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # ìºì‹œ í‚¤ ìƒì„±
            cache_key = f"{func.__name__}:{str(args)}:{str(kwargs)}"
            
            # ìºì‹œ í™•ì¸
            result = cache.get(cache_key)
            if result is not None:
                return result
            
            # ì‹¤í–‰ ë° ìºì‹±
            result = func(*args, **kwargs)
            cache.set(cache_key, result, timeout)
            
            return result
        return wrapper
    return decorator

# 3. ë¹„ë™ê¸° ì²˜ë¦¬
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncProcessor:
    def __init__(self):
        self.executor = ThreadPoolExecutor(max_workers=4)
    
    async def process_batch(self, items):
        """ë°°ì¹˜ ë¹„ë™ê¸° ì²˜ë¦¬"""
        loop = asyncio.get_event_loop()
        
        tasks = [
            loop.run_in_executor(self.executor, self.process_item, item)
            for item in items
        ]
        
        results = await asyncio.gather(*tasks)
        return results
    
    def process_item(self, item):
        """ê°œë³„ í•­ëª© ì²˜ë¦¬"""
        # CPU ì§‘ì•½ì  ì‘ì—…
        return expensive_operation(item)
```

### í…ŒìŠ¤íŠ¸ ì „ëµ
```python
# backend/tests/test_integration.py
import pytest
from django.test import TestCase
from channels.testing import WebsocketCommunicator
from chat.consumers import ChatConsumer

class ChatIntegrationTest(TestCase):
    """í†µí•© í…ŒìŠ¤íŠ¸"""
    
    @pytest.mark.asyncio
    async def test_chat_flow(self):
        """ì „ì²´ ì±„íŒ… í”Œë¡œìš° í…ŒìŠ¤íŠ¸"""
        # 1. WebSocket ì—°ê²°
        communicator = WebsocketCommunicator(
            ChatConsumer.as_asgi(),
            "/ws/chat/123/"
        )
        
        connected, _ = await communicator.connect()
        assert connected
        
        # 2. ë©”ì‹œì§€ ì „ì†¡
        await communicator.send_json_to({
            "type": "chat_message",
            "message": "Hello AI"
        })
        
        # 3. ì‘ë‹µ ìˆ˜ì‹ 
        response = await communicator.receive_json_from()
        assert response["type"] == "ai_chunk"
        
        # 4. ì—°ê²° ì¢…ë£Œ
        await communicator.disconnect()

# frontend-chat/src/components/__tests__/ChatInterface.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ChatInterface } from '../ChatInterface';
import { WebSocketService } from '../../services/websocket';

// Mock WebSocket
jest.mock('../../services/websocket');

describe('ChatInterface', () => {
    it('should send message on button click', async () => {
        const mockSend = jest.fn();
        (WebSocketService as jest.Mock).mockImplementation(() => ({
            send: mockSend,
            connect: jest.fn()
        }));
        
        render(<ChatInterface />);
        
        const input = screen.getByPlaceholderText('ë©”ì‹œì§€ ì…ë ¥...');
        const button = screen.getByText('ì „ì†¡');
        
        fireEvent.change(input, { target: { value: 'Test message' } });
        fireEvent.click(button);
        
        await waitFor(() => {
            expect(mockSend).toHaveBeenCalledWith('Test message');
        });
    });
});
```

## ğŸ“š ì°¸ê³  ìë£Œ

### ì•„í‚¤í…ì²˜ íŒ¨í„´
- [ë§ˆí‹´ íŒŒìš¸ëŸ¬ì˜ ì—”í„°í”„ë¼ì´ì¦ˆ ì• í”Œë¦¬ì¼€ì´ì…˜ ì•„í‚¤í…ì²˜ íŒ¨í„´](https://martinfowler.com/eaaCatalog/)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Domain-Driven Design](https://www.domainlanguage.com/ddd/)

### Django ì•„í‚¤í…ì²˜
- [Django Design Philosophies](https://docs.djangoproject.com/en/5.0/misc/design-philosophies/)
- [Two Scoops of Django](https://www.feldroy.com/books/two-scoops-of-django-3-x)
- [Django Best Practices](https://django-best-practices.readthedocs.io/)

### React ì•„í‚¤í…ì²˜
- [React íŒ¨í„´](https://www.patterns.dev/react)
- [React ì•„í‚¤í…ì²˜ ëª¨ë²” ì‚¬ë¡€](https://www.robinwieruch.de/react-architecture/)
- [Bulletproof React](https://github.com/alan2207/bulletproof-react)

### ì„±ëŠ¥ ìµœì í™”
- [Django ì„±ëŠ¥ ìµœì í™”](https://docs.djangoproject.com/en/5.0/topics/performance/)
- [React ì„±ëŠ¥ ìµœì í™”](https://react.dev/learn/render-and-commit)
- [ì›¹ ì„±ëŠ¥ ìµœì í™”](https://web.dev/performance/)

## ğŸ¯ í•µì‹¬ ì •ë¦¬

1. **ê³„ì¸µí™”ëœ ì•„í‚¤í…ì²˜**ë¡œ ê´€ì‹¬ì‚¬ë¥¼ ë¶„ë¦¬í•©ë‹ˆë‹¤
2. **ë„ë©”ì¸ ì¤‘ì‹¬ ì„¤ê³„**ë¡œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ëª…í™•íˆ í•©ë‹ˆë‹¤
3. **ì„œë¹„ìŠ¤ íŒ¨í„´**ìœ¼ë¡œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ìº¡ìŠí™”í•©ë‹ˆë‹¤
4. **ë¦¬í¬ì§€í† ë¦¬ íŒ¨í„´**ìœ¼ë¡œ ë°ì´í„° ì ‘ê·¼ì„ ì¶”ìƒí™”í•©ë‹ˆë‹¤
5. **í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ êµ¬ì¡°**ë¡œ í’ˆì§ˆì„ ë³´ì¥í•©ë‹ˆë‹¤

---

ë‹¤ìŒ: [09-ë¬¸ì œí•´ê²°ê³¼-ë””ë²„ê¹….md](./09-ë¬¸ì œí•´ê²°ê³¼-ë””ë²„ê¹….md)